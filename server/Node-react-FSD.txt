THIS ARE MY NOTES DURING DOING THE COURSE (yes, there are some obvious things here too, I come here back to remind myself how to do stuff)

- using passport for google's oath flow
    - installing "passport" (2 modules)
        - passport - general helpers for handling auth in Express apps
        - passport strategy - Helpers for authenticating with one very specific method (email/pssword, google, facebook etc) - the number of ways I want to authenticate 
                              defines how many strategy modules I need to install

        - modules used in the course
            - passport-google-oauth20
            - passport

    - how does the oauth work?
        user clicks login and I am redirecting them to certain route, specified by me.
        I have a route specified for that in my express app, that has passport authenticate method 'attached' after invoking it
        so passport makes a request with clientID, clientSecret, scope and callbackURL.
        After user grants permission to my app google redirects to callbackURL?code=2132/adsadsadakjn1221321 that code is information
        that I can use in the second passport.authenticate call and after second authentication I get: 
        
        - accessToken that allows to get user's data and do some actions on behalf of this user (expires after some time period)
        - refreshToken - allows to update accessToken

        after all those steps there is only work on my side: creating record in db, login/logout etc.
    - steps for using google oath
        - getting clientID and clientSecret tokens
            - registering the app in google.developers.console
            - enable api
            - library -> google+ in search
            - create credentials
                - left side-bar -> credentials
                - oAuth client ID option
            - consent screen - screen that is shown during "permission trigger"
                - only app name is not optional (I guess) 

            - what are these tokens?
                - clientID - public token (not data), it is id of my app in google's servers
                - clientSecret - confidential data, data only known by application and authorization server
            
        - storing these two tokens (basic version)
            - server/config/keys.js
                module.exports = { 
                    googleClientID: '12323',
                    googleClientSecret: '123'
                };
            
            - .gitignore file update to skip this config file, so no confidential data will be commited 

        - oauth error (400 uri_mismatch...)
            - after passing http://localhost:5000/ as callback uri, there comes an error, the reason is quite simple
              In code I have /auth/google/callback specified, I can not use / for this uri (in google), since everybody knows my clientID 
              and just changing uri to 'hacker.com/' will affect getting from google code that could be used to retrieve data that is why
              certain route is specified for that, with localhost, in the future that will be changed too

        - oauth with passport (google strategy)
            passport.use(
              new GoogleStrategy({
                clientID: keys.googleClientID,
                clientSecret: keys.googleClientSecret,
                callbackURL: '/auth/google/callback' // url that will be used after user grants permission, there will be code attached, it is route to handle on my side
              }, (accessToken, refreshToken, profile, done) => {
                console.log('Access Token:', accessToken);
                console.log('Refresh Token:', refreshToken);
                console.log('profile:', profile);
              })
            );

            app.get('/auth/google', passport.authenticate('google', { // google as name of strategy (it is configured in passport already)
              scope: ['profile', 'email'] // scopes (things I want have access to)
            }));

            app.get('/auth/google/callback', passport.authenticate('google')); // passport allows to authenticate based on code in url

- server structure refactor (I am not sure if this is better than using routes)
    - auth routes
        module.exports = (app) => {
            app.get('/auth/google', passport.authenticate('google', { // google as name of strategy (it is configured in passport already)
                scope: ['profile', 'email'] // scopes (things I want have access to)
            }));

            app.get('/auth/google/callback', passport.authenticate('google')); // passport allows to authenticate based on code in url
        }
    
    - usage in index.js
        require('./routes/authRoutes')(app);

- theory of authentication
    - http is stateless - two different requests can not share data (auth request won't tell nex request that user is authenticated)
    - how does it work:
        - after login process server returns a token, through which user will identify in other requests
        - in cookie based authentication there is just cookie (header has value of Set-Cookie: 'random_token'), this cookie will be saved in browser
          and all next requests will be made with that cookie in header 
    
    - user/password vs oauth
        - in user/password data given by user is compared with data already stored in database, or in case someone is registering, just storing the data...
        - in oauth user goes through the 3rd party authentication process every time, but I assume, that they have been here already and signed up
          during which I stored some not changed by google data as id and compare it every time user tries to login, so I can identify them or store id data
          when they appear first time

- setting up remotely hosted mongodb - mLab (easy to configure, gives URI to connect)

- user authetincation in practice (in code)
    - user clicks sing up
        - goes through oauth and code comes to:
                - check if user already exists by googleID 
                    - if exists done(null, existingUser) - no error, passing user found in db
                    - if does not exist 
                        new User({ googleId: profile.id }).save().then(user => { - create new user and invoke done with created one in then since async
                          done(null, user);
                        });

            passport.use(
              new GoogleStrategy(
                {
                  clientID: keys.googleClientID,
                  clientSecret: keys.googleClientSecret,
                  callbackURL: "/auth/google/callback" // url that will be used after user grants permission, there will be code attached, it is route to handle on my side
                },
                (accessToken, refreshToken, profile, done) => {
                  User.findOne({ googleId: profile.id })
                    .then(existingUser => {
                      if (existingUser) {
                        done(null, existingUser); // arg1: error object, arg2: data from db
                      } else {
                        new User({ googleId: profile.id }).save().then(user => {
                          done(null, user);
                        });
                      }
                    })
                    .catch(err => {
                      console.log(err);
                    });
                }
              )
            );
    - after singnig up :
        - this function takes his data and encodes, so cookie can store his unique data
            passport.serializeUser((user, done) => {
              // arg1: instance of user passed in done(null, user) in then of findOne or save below
              done(null, user.id); // Using mongodb id (can access to id instead of _id.id), that will be in cookie
            });

    - to make this possible there need to be two middlewares applied, to use cookies in express and passport

        app.use(
          cookieSession({
            maxAge: 30 * 24 * 60 * 60 * 1000, // how long cookie will be held in browser until it will expire
            keys: [keys.cookieKey] // just random char sequence, it is array, so it will pick one if more declared
          })
        );

        // Telling passport to use cookies to handle authentication
        app.use(passport.initialize());
        app.use(passport.session());

    - if user makes a request, this method is invoked, to get user instance from cookie data
        passport.deserializeUser((id, done) => {
          User.findById(id).then((user) => {
        		done(null, user)
        	});
        });

    !IMPORTANT!: after deserializing user there comes user instance in req.user, so ready to use object
    Basically passport is a tool that I need to tell, what data I want to use (encoded data), so 
    everything will work under the hood

    - logout user (passport does all the work attaching a special function that resets the cookie)

- Setting up production and dev environment (there is different google api and mongodb setup for prod and dev)
    - steps to do:
        - creating dev file with hardcoded data (for local development) - this file is not committed
        - creating prod file that has usage of local environment variables
        - changing keys.js, where now it is decided what to require, based on NODE_ENV env variable
    
    - environemt variables setup on heroku
        - reveal config vars
        - using keys with name of key names form prod.js and values hardcoded like in dev.js (it is secure there)

- Problem with https vs http (400 uri_mismatch)
    - in google https given
    - what causes this - proxy used by heroku, google strategy can see that it is used so the callback comes without http, but I can trust heroku's proxy, at least I need to :D 
    - solutions:
        - adding some option to google strategy, that will ignore that heroku uses proxy
            - proxy: true
        - passing whole callback url with https

- using react with express
    - running client and server simultaneous (using concurrently)
        - changes in package.json in server (three last scripts are responsible for that)
            "scripts": {
              "start": "node index.js",
              "server": "nodemon index.js",
              "client": "npm run start --prefix client",
              "dev": "concurrently \"npm run server\" \"npm run client\""
            },
        - from this time npm run dev runs client and server in one console
    
    - conencting express server with react server (links)
        - problem to face
            - <a href="/google/auth" /> leading to localhost:3000 instead of localhost:5000 that express server is running on
        - steps to do
            - installing http-proxy-middleware
            - creating file that sets up this middleware and exports it (can be found in client/src/setupProxy)
            
    - difference between react and express on dev and on production
        - on dev env
            - there are two servers on :3000 and :5000, that is why I need to use proxy, because all link would lead to localhost:3000 which is not my
              express server on
        - on prod
            - babel and webpack after doing manually : react-scripts build get rid of server and creates structure:
                - build/static
                - static/css
                - static/js
                - static/media
              all data is now ready to be "inserted" in express server structure so there will no longer be two servers
        
        - problems if I didn't go with this proxy approach
            - cookies are held on localhost:3000, localhost:5000 wouldn't get requests with cookies included
            - CORS request from :3000 to :5000 (treated like different domains)

    - async-await
        fetchAlbums = () => {
            fetch('https://rallycoding.herokuapp.com/api/music_albums')
                .then((res) => res.json()) // returning json, for chained then 
                .then((json) => console.log(json));
        };
        
        
        fetchAlbumsAA = async () => {
            const res = await fetch('https://rallycoding.herokuapp.com/api/music_albums');
            const json = await res.json(); // returns Promise also 
            console.log(json);
        };
        
        fetchAlbumsAA();

- client (first setups and component structure creation)
    - main components used for setups
        - index.js (upper layer) - responsible for redux setup
        - App.js (lower layer) - responsible for React router setup
    - used dependencies
        - redux
        - react-redux
        - react-router-dom
    
    - redux high level structure
        - two combined reducers 
            - authReducer 
            - surveysReducer